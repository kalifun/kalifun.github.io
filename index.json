[{"categories":null,"contents":"","date":"Nov 26","permalink":"https://blog.kalifun.top/projects/lazyswitch/","tags":null,"title":"lazy switch"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://blog.kalifun.top/projects/proto3tools/","tags":null,"title":"vscode proto3 tools"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://blog.kalifun.top/projects/dotfiles/","tags":null,"title":"dotfiles"},{"categories":["dev","workflow"],"contents":" 工欲善其事，必先利其器\n这个是记录自己在工作流上感觉很方便，很好用的工具集。可能会随着时间的推移它会变得越来越有效率。\n你也可以理解我正在直播带货，我会将这些好用的工具分享给各位，但不用担心他们都是免费的。\n我会按照工具的分类来介绍，也会提供一些简单的玩法，更多可能需要你自己的探索。\n输入法 输入法是日常工作中必不可少的工具,选择一个高效的输入方案可以极大提高输入速度。本人推荐使用双拼输入方案,相比全拼,它只需通过声母+韵母的组合即可输入所需的汉字,击键次数更少,输入效率更高。\n双拼是汉语拼音输入法的一种编码方案。相对于全拼而言，使用双拼输入汉字时只需输入一个代表声母的字母，一个代表韵母的字母，就可以打出任意一个中文字了。\n我举个简单的例子：\n全拼 双 s h u a n g 我们需要输入6次 双拼 双 sh uang我们只需要输入2次 那会好奇，键盘上没有这种组合键啊？其实和五笔是一个逻辑，就是它有自己的一套标准，需要我们记忆键位，才能完美的输出自己想要的字。市面有很多双拼方案，他们的键位映射是不一样的，所以可以先去了解不同的方案的键位，我们这边推荐小鹤双拼。\n小鹤双拼 当我们输入双的时候，我们只需要u + l，就可以了，这个需要自己形成肌肉记忆。推荐看看官网，会有一些记忆法可以帮助到你。\n如果对输入法隐私有所顾虑,也可以考虑使用开源的Rime输入法引擎,它支持高度定制,并且无需连接在线服务器。\n启动器 Raycast Raycast is a blazingly fast, totally extendable launcher. It lets you complete tasks, calculate, share common links, and much more.\n具体使用这边就不介绍了，它是一个功能丰富的启动器，我们可以自定义启动器的快捷键，我这边的是option + space. 然后你可以同通过启动器来启动软件，不再需要翻软件列表了。当然它有很多的功能，日历，剪切板历史，窗口管理等\u0026hellip;\nHotkey 你可以理解它其实就是全局的快捷键，我们可以将常用的application设置hotkey。这样我们可以快速的打开它。换着快速切换到它活跃的窗口。\nWindow Management 我们会不会经常需要左边打开浏览器，右边打开编辑器。你还在那不断的拖拽窗口来调整他们的大小吗？\n很惊喜，Raycast自带窗口管理器，我们可以通过它的command或者自己设置hotkey来进行窗口管理。\n它拥有丰富的插件库，如果你感兴趣可以去翻翻，还有很多好的功能。\n终端 Wezterm WezTerm is a powerful cross-platform terminal emulator and multiplexer written by @wez and implemented in Rust\n如果喜欢在终端上编程的同学，也许它是一个不错的选择。它可以使用lua进行配置，并自定义快捷键来对pane进行操作。如果你是win+wsl的用户，我真心推荐。\nfzf fzf is a general-purpose command-line fuzzy finder.\n我会用于搜索目录，并通过tmux来创建一个session\nzoxide A smarter cd command. Supports all major shells.\n如果我们配置好了zoxide后，我们进入过一个文件夹/Users/kalifun/Code/github/openCore下次我们还这样输入完整路径？No！我们可以模糊匹配。\n1 z github open 浏览器 Arc 感觉是一个用了就回不去的浏览器，它虽然是Chromium内核，但确在改变我们使用正常浏览器的思路。 我想我们的浏览器tab页多到头皮发麻吧，但很多页面呢都是搜索引擎的列表什么的。Arc可以悬浮查看页面，如果满意可以全屏，如果不满意就直接关闭了这个检索结果。或者你在浏览博客，有人引入了其他的页面，你想看看写的是什么，它可以直接split，将会分出一半的屏幕给你预览。 还有什么Workspace，还有一些ai功能，都是非常好用的。\n这里我也没有提到扩展，有了扩展我们可以让效率再次提升。\n开发工具 Neovim 我非常喜欢结合tmux一起来使用，这样我可以同时管理多个项目，且切换起来非常方便。 大多数人一看到这个就会觉得你在装，用VSCode不用，非要用这种毛坯？一堆的快捷键，用着好繁琐。\n这些都是让我使用它的原因，使用它我可以让我慢慢的抛弃鼠标，能键盘做的事情绝不用鼠标。 如果你觉得配置好头痛，你可以使用lazyvim或者其他的配置，他们都帮我配置好了，你可以直接使用。可能一些快捷键需要熟悉一下。\ntmux prefix + w 窗口列表 prefix + b 下个窗口 \u0026hellip;\u0026hellip;.\n总结 我这里不想过多的去讲配置，使用方法，不然每个软件都可以输出一个文章了。后面我也会写一些我的配置，也是用来记录。我觉得在工作流程中如果能用快捷键解决的就别用鼠标去点了，真的操作起来慢，还费手腕。\n我也简单说说我这边用的爽的点吧！\n我要聊微信的时候option + c 我需要打开wezterm时option + w 我需要使用浏览器时option + a 我在Arc上需要搜索lazyvim代码库时，⌘ + t,输入gh + tab + lazyvim。浏览器就帮我打开GitHub搜索lazyvim代码库。 还有很多使用场景我就不一一列举，如果感兴趣我们可以交流交流。 ","date":"Mar 25","permalink":"https://blog.kalifun.top/post/workflow/workflow_wizard/","tags":null,"title":"Workflow Wizard"},{"categories":["golang","golang开源库"],"contents":" 编写高并发程序常常让人头疼:代码冗余、死锁风险、逻辑复杂等等。Go语言的标准库提供了sync.WaitGroup、channel等工具来实现并发控制,但使用起来还是有一些困难。conc项目就是为了解决这些痛点而生的。\n主要功能 1. WaitGroup 在编写并发demo时,我们经常需要用到sync.WaitGroup来等待所有goroutine执行完毕。每次都要添加Add(),在goroutine退出前调用Done(),最后Wait()等待,非常繁琐。\n标准库示例:\n1 2 3 4 5 6 7 8 9 10 11 12 func main() { var wg sync.WaitGroup for i := 0; i \u0026lt; 10; i++ { wg.Add(1) go func() { defer wg.Done() // 如果doSomething()panic,程序会崩溃 doSomething() }() } wg.Wait() } 使用conc后:\n1 2 3 4 5 6 7 func main() { var wg conc.WaitGroup for i := 0; i \u0026lt; 10; i++ { wg.Go(doSomething) } wg.Wait() } conc对WaitGroup进行了封装,自动执行Add和Done操作。更重要的是,如果任一goroutine发生panic,错误会被捕获,在Wait时安全重新panic,而不会直接导致程序崩溃。\n2. ForEach 在并发处理数据时,我们往往需要创建一个channel,启动多个goroutine从channel读取数据并处理。代码十分冗长:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func process(values []int) { feeder := make(chan int, 8) var wg sync.WaitGroup for i := 0; i \u0026lt; 10; i++ { wg.Add(1) go func() { defer wg.Done() for elem := range feeder { handle(elem) } }() } for _, value := range values { feeder \u0026lt;- value } close(feeder) wg.Wait() } 使用conc的ForEach,实现变得十分精简:\n1 2 3 func process(values []int) { iter.ForEach(values, handle) } ForEach会自动启动足够数量的goroutine,并发读取slice中的数据,应用handle函数进行处理。\n3. Map 另一个常见场景是从外部接口获取数据,并并行处理这些数据生成新的结果。传统实现如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func concMap( input []int, f func(int) int, ) []int { res := make([]int, len(input)) var idx atomic.Int64 var wg sync.WaitGroup for i := 0; i \u0026lt; 10; i++ { wg.Add(1) go func() { defer wg.Done() for { i := int(idx.Add(1) - 1) if i \u0026gt;= len(input) { return } res[i] = f(input[i]) } }() } wg.Wait() return res } 使用conc的Map方法就简洁多了:\n1 2 3 4 5 6 func concMap( input []int, f func(*int) int, ) []int { return iter.Map(input, f) } Map会自动创建一组goroutine,并发地对slice中每个元素应用f函数,最终返回结果slice。\n代码分析 conc项目的核心是错误捕获和并发控制,下面分析其实现原理。\n1. Catcher Catcher用于捕获并保存panic产生的错误信息。它的核心是CompareAndSwap原子操作,确保多个goroutine同时捕获panic时也能保证数据安全。\n1 2 3 4 5 6 7 8 9 type Catcher struct { recovered atomic.Pointer[Recovered] } type Recovered struct { Value any Callers []uintptr Stack []byte } Catcher的Try方法用于执行传入的函数,在panic时通过recover捕获错误:\n1 2 3 4 5 6 7 8 9 10 11 func (p *Catcher) Try(f func()) { defer p.tryRecover() f() } func (p *Catcher) tryRecover() { if val := recover(); val != nil { rp := NewRecovered(1, val) p.recovered.CompareAndSwap(nil, \u0026amp;rp) } } Repanic则检查之前是否捕获了panic,如果有就重新panic,确保主goroutine能获取完整的错误堆栈信息。\n2. WaitGroup WaitGroup通过组合Catcher和sync.WaitGroup,实现自动错误捕获:\n1 2 3 4 5 6 7 8 9 10 11 12 type WaitGroup struct { wg sync.WaitGroup pc panics.Catcher } func (h *WaitGroup) Go(f func()) { h.wg.Add(1) go func() { defer h.wg.Done() h.pc.Try(f) }() } Go方法启动新的goroutine执行f,受Try保护,发生panic时被捕获到Catcher中。Wait则首先等待所有goroutine退出,之后检查Catcher中是否存在被捕获的panic,如果有就重新panic。\n3. ForEach和Map ForEach和Map的实现核心其实就是对slice的并发遍历,应用指定的处理函数。通过原子操作cnt确保索引唯一,goroutine安全地读取不同的slice元素。这里就不再赘述了。\n总的来说,conc项目通过对WaitGroup、channel等并发原语的封装,简化了并发程序的编写。同时其错误捕获机制能最大程度地避免由panic导致的程序崩溃,极大提高了程序的健壮性。这些设计思路和技术细节,无疑能给Go并发编程带来极大的启发。\n","date":"Mar 10","permalink":"https://blog.kalifun.top/post/golang/conc/","tags":null,"title":"解锁Go并发编程的新姿势 -- conc项目解析"},{"categories":["archlinux"],"contents":"I recently installed Arch. but my network card is not working.\nI was surprised, i still had to install the driver myself?\nThe Arch documentation is so rich.\nYou can visit this link.\nLook for problems 1 lspic -vnn -d 14e4: The NIC is already recognized by the system.\ndisplay message Check whether the system starts abnormally.\n1 dmesg I thought it was a driver error and I tried uninstalling the installation. does not solve the problem.\nhwinfo 1 hwinfo --netcard --bluetooth | grep -Ei \u0026#34;(speed|hotplug|model|status|cmd|file|detected|driver:)\u0026#34; | grep -v \u0026#34;Config S\u0026#34; To find the problem, the driver needs to execute the following command:\n1 modprobe wl But to restart, you still need to execute the command again.\nIt\u0026rsquo;s awful, I need to really fix it. Maybe execute a script at startup?\n","date":"Mar 06","permalink":"https://blog.kalifun.top/post/arch/broadcom_wireless_arch/","tags":null,"title":"Broadcom Wrieless Archlinux"},{"categories":null,"contents":"I left nothing behind\nIntroduction hi, I\u0026rsquo;am kalifun.\nI majored in information security in college and taught myself back-end development as a rookie.\nContact Me Github: kalifun\nEmail: a2FsaWZ1bkBvdXRsb29rLmNvbQ==\n","date":"Jan 19","permalink":"https://blog.kalifun.top/me/about/","tags":null,"title":"About Me"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://blog.kalifun.top/articles/","tags":null,"title":"Articles"}]