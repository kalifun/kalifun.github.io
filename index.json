[{"categories":null,"contents":"","date":"Nov 26","permalink":"https://blog.kalifun.top/projects/lazyswitch/","tags":null,"title":"lazy switch"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://blog.kalifun.top/projects/proto3tools/","tags":null,"title":"vscode proto3 tools"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://blog.kalifun.top/projects/dotfiles/","tags":null,"title":"dotfiles"},{"categories":["dev","workflow"],"contents":" 工欲善其事，必先利其器\n这个是记录自己在工作流上感觉很方便，很好用的工具集。可能会随着时间的推移它会变得越来越有效率。\n你也可以理解我正在直播带货，我会将这些好用的工具分享给各位，但不用担心他们都是免费的。\n我会按照工具的分类来介绍，也会提供一些简单的玩法，更多可能需要你自己的探索。\n输入法 输入法是日常工作中必不可少的工具,选择一个高效的输入方案可以极大提高输入速度。本人推荐使用双拼输入方案,相比全拼,它只需通过声母+韵母的组合即可输入所需的汉字,击键次数更少,输入效率更高。\n双拼是汉语拼音输入法的一种编码方案。相对于全拼而言，使用双拼输入汉字时只需输入一个代表声母的字母，一个代表韵母的字母，就可以打出任意一个中文字了。\n我举个简单的例子：\n全拼 双 s h u a n g 我们需要输入6次 双拼 双 sh uang我们只需要输入2次 那会好奇，键盘上没有这种组合键啊？其实和五笔是一个逻辑，就是它有自己的一套标准，需要我们记忆键位，才能完美的输出自己想要的字。市面有很多双拼方案，他们的键位映射是不一样的，所以可以先去了解不同的方案的键位，我们这边推荐小鹤双拼。\n小鹤双拼 当我们输入双的时候，我们只需要u + l，就可以了，这个需要自己形成肌肉记忆。推荐看看官网，会有一些记忆法可以帮助到你。\n如果对输入法隐私有所顾虑,也可以考虑使用开源的Rime输入法引擎,它支持高度定制,并且无需连接在线服务器。\n启动器 Raycast Raycast is a blazingly fast, totally extendable launcher. It lets you complete tasks, calculate, share common links, and much more.\n具体使用这边就不介绍了，它是一个功能丰富的启动器，我们可以自定义启动器的快捷键，我这边的是option + space. 然后你可以同通过启动器来启动软件，不再需要翻软件列表了。当然它有很多的功能，日历，剪切板历史，窗口管理等\u0026hellip;\nHotkey 你可以理解它其实就是全局的快捷键，我们可以将常用的application设置hotkey。这样我们可以快速的打开它。换着快速切换到它活跃的窗口。\nWindow Management 我们会不会经常需要左边打开浏览器，右边打开编辑器。你还在那不断的拖拽窗口来调整他们的大小吗？\n很惊喜，Raycast自带窗口管理器，我们可以通过它的command或者自己设置hotkey来进行窗口管理。\n它拥有丰富的插件库，如果你感兴趣可以去翻翻，还有很多好的功能。\n终端 Wezterm WezTerm is a powerful cross-platform terminal emulator and multiplexer written by @wez and implemented in Rust\n如果喜欢在终端上编程的同学，也许它是一个不错的选择。它可以使用lua进行配置，并自定义快捷键来对pane进行操作。如果你是win+wsl的用户，我真心推荐。\nfzf fzf is a general-purpose command-line fuzzy finder.\n我会用于搜索目录，并通过tmux来创建一个session\nzoxide A smarter cd command. Supports all major shells.\n如果我们配置好了zoxide后，我们进入过一个文件夹/Users/kalifun/Code/github/openCore下次我们还这样输入完整路径？No！我们可以模糊匹配。\n1 z github open 浏览器 Arc 感觉是一个用了就回不去的浏览器，它虽然是Chromium内核，但确在改变我们使用正常浏览器的思路。 我想我们的浏览器tab页多到头皮发麻吧，但很多页面呢都是搜索引擎的列表什么的。Arc可以悬浮查看页面，如果满意可以全屏，如果不满意就直接关闭了这个检索结果。或者你在浏览博客，有人引入了其他的页面，你想看看写的是什么，它可以直接split，将会分出一半的屏幕给你预览。 还有什么Workspace，还有一些ai功能，都是非常好用的。\n这里我也没有提到扩展，有了扩展我们可以让效率再次提升。\n开发工具 Neovim 我非常喜欢结合tmux一起来使用，这样我可以同时管理多个项目，且切换起来非常方便。 大多数人一看到这个就会觉得你在装，用VSCode不用，非要用这种毛坯？一堆的快捷键，用着好繁琐。\n这些都是让我使用它的原因，使用它我可以让我慢慢的抛弃鼠标，能键盘做的事情绝不用鼠标。 如果你觉得配置好头痛，你可以使用lazyvim或者其他的配置，他们都帮我配置好了，你可以直接使用。可能一些快捷键需要熟悉一下。\ntmux prefix + w 窗口列表 prefix + b 下个窗口 \u0026hellip;\u0026hellip;.\n总结 我这里不想过多的去讲配置，使用方法，不然每个软件都可以输出一个文章了。后面我也会写一些我的配置，也是用来记录。我觉得在工作流程中如果能用快捷键解决的就别用鼠标去点了，真的操作起来慢，还费手腕。\n我也简单说说我这边用的爽的点吧！\n我要聊微信的时候option + c 我需要打开wezterm时option + w 我需要使用浏览器时option + a 我在Arc上需要搜索lazyvim代码库时，⌘ + t,输入gh + tab + lazyvim。浏览器就帮我打开GitHub搜索lazyvim代码库。 还有很多使用场景我就不一一列举，如果感兴趣我们可以交流交流。 ","date":"Mar 25","permalink":"https://blog.kalifun.top/post/workflow/workflow_wizard/","tags":null,"title":"Workflow Wizard"},{"categories":["golang","test"],"contents":"在软件开发中，测试是确保代码质量和功能稳定性的关键步骤之一。然而，除了其在质量保证方面的重要性之外，测试还对我们的编程思想产生了深远的影响。通过本文，我们将探讨测试如何塑造我们的编程思维，以及如何通过测试驱动开发（TDD）、重构和面向对象编程等技术来提高代码质量和开发效率。\n测试的种类 单元测试 单元测试是一个代码块，用于验证较小、孤立的应用程序代码块（通常是函数或方法）的准确性。\n单元测试的要求：\n程序需要采用这种命名规则 xxx_test.go 测试函数名必须以Test 开头 测试函数参数参数是 t *testing.T 性能测试 性能测试是采用测试手段对软件的响应及时性进行评价的一种方式。\n性能测试的要求：\n程序需要采用这种命名规则 xxx_test.go 测试函数名必须以Benchmark 开头 测试函数参数参数是 b *testing.B 模糊测试 模糊测试是通过向目标系统提供非预期的输入并监视异常结果来发现软件漏洞的方法。\n模糊测试的要求：\n程序需要采用这种命名规则 xxx_test.go 测试函数名必须以Fuzz 开头 测试函数参数参数是 f *testing.F 测试驱动开发 如果采用测试驱动开发(TDD)的流程,我们会先编写测试用例,再基于测试用例来实现最小可行的代码。这种做法可以促使我们先思考设计,再动手编码,从而产生更加优雅、简洁的代码。\n现在我们现在有一个需求，是求解矩形的面积。按照我们常规的思路我们是先实现面积的代码，然后再编写测试用例。但是在很多情况下，实现完需求就接着写其他的了。并不会编写测试用例，这样代码并不能保证它的可靠性。\n所以我们应该采用TDD的形式来开发，会得到不一样的效果。\nrectangle_test.go\n1 2 3 4 5 6 7 8 9 10 11 package rectangle import \u0026#34;testing\u0026#34; func TestRectangleArea(t *testing.T) { got := Area(2, 5) want := 10.0 if got != want { t.Errorf(\u0026#34;got \u0026#39;%f\u0026#39; want \u0026#39;%f\u0026#39;\u0026#34;, got, want) } } 1 2 3 4 ❯ go test -v # demo/rectangle [demo/rectangle.test] ./rectangle_test.go:6:9: undefined: Area FAIL demo/rectangle [build failed] 然后我们再具体实现方法。\nrectangle.go\n1 2 3 4 5 package rectangle func Area(width, height float64) float64 { return width * height } 1 2 3 4 5 ❯ go test -v === RUN TestRectangleArea --- PASS: TestRectangleArea (0.00s) PASS ok demo/rectangle 0.006s 重构 上面是一个很简单的用例，我们需要考虑更多可能，所以我们可以引入表格测试的概念。\nrectangle_test.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 package rectangle import \u0026#34;testing\u0026#34; func TestArea(t *testing.T) { type args struct { width float64 height float64 } tests := []struct { name string args args want float64 }{ { name: \u0026#34;the same\u0026#34;, args: args{ width: 1, height: 1, }, want: 1.0, }, { name: \u0026#34;have zero\u0026#34;, args: args{ width: 2, height: 0, }, want: 0.0, }, { name: \u0026#34;set float\u0026#34;, args: args{ width: 2.1, height: 5.3, }, want: 11.13, }, { name: \u0026#34;both zero\u0026#34;, args: args{ height: 0, width: 0, }, want: 0.0, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { if got := Area(tt.args.width, tt.args.height); got != tt.want { t.Errorf(\u0026#34;Area() = %v, want %v\u0026#34;, got, tt.want) } }) } } 我们接到一个需求是计算矩形的周长，此时我们优先将测试代码实现了。\nrectangle_test.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 func TestCircumference(t *testing.T) { type args struct { width float64 height float64 } tests := []struct { name string args args want float64 }{ { name: \u0026#34;the same\u0026#34;, args: args{ width: 1, height: 1, }, want: 4.0, }, { name: \u0026#34;have zero\u0026#34;, args: args{ width: 2, height: 0, }, want: 0.0, }, { name: \u0026#34;set float\u0026#34;, args: args{ width: 2.1, height: 5.3, }, want: 14.8, }, { name: \u0026#34;both zero\u0026#34;, args: args{ height: 0, width: 0, }, want: 0.0, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { if got := Circumference(tt.args.width, tt.args.height); got != tt.want { t.Errorf(\u0026#34;Area() = %v, want %v\u0026#34;, got, tt.want) } }) } } 然后我们要实现函数时，你有没有发现和我们求面积的时候入参和出参都一样，而且它都属于矩形的计算的一种。如果我们还是按照原来的函数来进行开发，用户就会很难受，我面积周长都要传参。那我们改造一下吧！\nrectangle.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 package rectangle type Rectangle struct { Width, Height float64 } func (r Rectangle) Area() float64 { return r.Width * r.Height } func (r Rectangle) Circumference() float64 { return 2 * (r.Width + r.Height) } 这样对于调用方来说只需要new一次Rectangle,就可以计算Area和Circumference。\n此时我们的测试代码又报红了，我们来修改它，让它不再报错。\nrectangle_test.go\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package rectangle import \u0026#34;testing\u0026#34; func TestRectangle_Area(t *testing.T) { type fields struct { Width float64 Height float64 } tests := []struct { name string fields fields want float64 }{ // code ....... } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { r := Rectangle{ Width: tt.fields.Width, Height: tt.fields.Height, } if got := r.Area(); got != tt.want { t.Errorf(\u0026#34;Rectangle.Area() = %v, want %v\u0026#34;, got, tt.want) } }) } } func TestRectangle_Circumference(t *testing.T) { type fields struct { Width float64 Height float64 } tests := []struct { name string fields fields want float64 }{ // code ....... } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { r := Rectangle{ Width: tt.fields.Width, Height: tt.fields.Height, } if got := r.Circumference(); got != tt.want { t.Errorf(\u0026#34;Rectangle.Circumference() = %v, want %v\u0026#34;, got, tt.want) } }) } } 面向对象 此时我们又接到一个需求需要计算圆的面积和周长。我们会发现这不是和我们写矩形的时候一样吗？没错，在大多数图形来讲都有计算面积的公式，所以我们可以对它进行抽象。 shape.go\n1 2 3 4 5 6 package geometry type Shape interface { Area() float64 Circumference() float64 } 然后再将圆实现这两个接口。这样的好处就在于如果我们对图形还要包一层进行业务开发，我们就无须指定图形的类型就能执行下面的方法了。\n1 2 3 4 5 6 7 8 9 10 11 12 // 业务需求：计算一个画板上的所有的图形面积(不一定很贴切) type DrawingBoard struct { shapes []Shape } func (db DrawingBoard) Area() float64 { sum := 0.0 for _, v := range db.shapes { sum += v.Area() } return sum } 像这种接口我们应该如何测试呢？因为它并没有具体的对象，所以这种情况我们就用使用mock来实现了。\n1 2 3 4 5 //go:generate mockgen -destination=./mock/mock_shape.go -package mock -source=shape.go type Shape interface { Area() float64 Circumference() float64 } 1 go generate 此时就会给我们生成mock代码。那我们业务代码要如何进行测试呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 package geometry import ( \u0026#34;xxx/xxx/geometry/mock\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;go.uber.org/mock/gomock\u0026#34; ) func TestDrawingBoard_Area(t *testing.T) { ctr := gomock.NewController(t) defer ctr.Finish() mockShape := mock.NewMockShape(ctr) mockShape.EXPECT().Area().DoAndReturn(func() float64 { return 10.0 }) mockShape1 := mock.NewMockShape(ctr) mockShape1.EXPECT().Area().DoAndReturn(func() float64 { return 0.0 }) mockShape2 := mock.NewMockShape(ctr) mockShape2.EXPECT().Area().DoAndReturn(func() float64 { return 0.0 }) mockShape3 := mock.NewMockShape(ctr) mockShape3.EXPECT().Area().DoAndReturn(func() float64 { return 5.5 }) type fields struct { shapes []Shape } tests := []struct { name string fields fields want float64 }{ { name: \u0026#34;mock one\u0026#34;, fields: fields{ shapes: []Shape{mockShape}, }, want: 10.0, }, { name: \u0026#34;zero\u0026#34;, fields: fields{ shapes: []Shape{ mockShape1, }, }, want: 0.0, }, { name: \u0026#34;have zero\u0026#34;, fields: fields{ shapes: []Shape{ mockShape2, mockShape3, }, }, want: 5.5, }, } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { db := DrawingBoard{ shapes: tt.fields.shapes, } if got := db.Area(); got != tt.want { t.Errorf(\u0026#34;DrawingBoard.Area() = %v, want %v\u0026#34;, got, tt.want) } }) } } 我们通过mock来帮助我们实现了这些实例。这个例子比较简单，所以有时候也可以不需要这么写，你也可以自己定义对象来实现接口。\n代码安全 模糊测试通常是自动化的，可用于测试功能和安全缺陷。 功能性模糊测试包括向程序输入无效数据以检查意外行为。\n在有些方法中，我们不可能将所有可能性都枚举出来，此时fuzz就能帮助我们了。\n我们有一个需求，是比较两个字节数组是否相等。单元测试代码我就省略了，可以结合上面的代码自己实现哦。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package fuzzdemo func Equal(a []byte, b []byte) bool { // 检查切片的长度是否相同 if len(a) != len(b) { return false } for i := range a { // 检查同一索引中的元素是否相同 if a[i] != b[i] { return false } } return true } 1 2 3 4 5 func FuzzEqual(f *testing.F) { f.Fuzz(func(t *testing.T, a, b []byte) { Equal(a, b) }) } 1 go test -fuzz . 需要注意的是fuzz需要手动进行停止。\n总结 通过测试和测试驱动开发（TDD），我们能够改变我们的编程思维方式。测试不仅仅是一种验证代码正确性的手段，更重要的是它塑造了我们对代码的设计、编写和维护的思考方式。采用TDD的开发模式，我们首先编写测试用例，然后再编写代码以满足这些测试用例，这促使我们在编写代码之前就深入思考问题的解决方案，从而产生更加健壮、可靠、可维护的代码。\n通过重构技术，我们能够改进现有的代码结构和设计，使其更加清晰、简洁、易于理解和维护。重构是持续改进代码质量的过程，通过识别和消除代码中的坏味道，我们能够不断提高代码的可读性、可维护性和灵活性。\n面向对象编程提供了一种组织和抽象代码的方式，通过将数据和方法封装在对象中，我们能够更好地管理复杂性，并实现代码的重用性和可扩展性。面向对象的思想使我们能够将现实世界中的问题映射到代码中，从而更好地理解和解决问题。\n最后，通过测试和模糊测试，我们能够确保代码的安全性和稳定性。测试不仅仅是一种验证功能的手段，还可以帮助我们发现和修复潜在的安全漏洞和异常行为，从而提高系统的可靠性和安全性。\n综上所述，测试对编程思维的影响是深远的，它不仅改变了我们对代码质量和可靠性的认识，还促使我们采用更加健壮和可维护的开发方式，从而提高软件开发的效率和质量。\n","date":"Mar 25","permalink":"https://blog.kalifun.top/post/golang/tests/","tags":null,"title":"探索golang测试的多种形式"},{"categories":["dev","go","math model"],"contents":"有限状态机（英语：finite-state machine，缩写：FSM）又称有限状态自动机（英语：finite-state automaton，缩写：FSA），简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。\n状态机是由以下几个核心组成：\n状态（state）：表示我们常见的a-\u0026gt;b-\u0026gt;c的状态序列。 事件（event）：触发从一个状态到另一个状态转换的条件。 动作（action）：在从一个状态转换到另一个状态时执行的具体操作。 转换（transition）：表示从一个状态到另一个状态的过程。 使用状态机的原因 随着项目的迭代，状态的数量可能会越来越多。以前可能还能通过使用if和switch语句来维护状态，但随着状态的增加，这种方法变得难以应付。状态的嵌套层级越来越深，并且许多产品还涉及到状态的回退，导致状态转换的判断变得复杂且难以维护。\n使用状态机，我们可以根据预先定义好的状态自动进行状态流转。通过将状态和行为进行抽象和模块化，我们可以更好地管理和维护状态。\n项目实践 下面是一个简单的示例，展示了一个真实项目中的状态流转：\n状态 值 操作 标注待领取 1 领取: 标注中 标注中 2 提交: 内检待领取 内检待领取 3 领取: 内检中 内检中 4 提交: 验收待领取 打回: 标注待领取 验收待领取 5 领取: 验收中 验收中 6 提交: 已完成 打回: 内检待领取 已完成 7 在这个例子中，我们先构建了一个状态和操作的映射表（Map），然后根据事件来判断要执行的操作。如果存在对应的事件和操作，就进行状态的转换。这样就完成了整个流程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 package main import ( \u0026#34;fmt\u0026#34; ) func main() { Run(Default, Submit) Run(MarkPick, Submit) Run(Mark, Submit) Run(MarkPick, Receive) Run(Check, CallBack) } func Run(state State, event Event) { if v, ok := transitions[state][event]; ok { s := \u0026#34;\u0026#34; if v1, ok := stateName[state]; ok { s = v1 } s2 := \u0026#34;\u0026#34; if v2, ok := stateName[v]; ok { s2 = v2 } fmt.Printf(\u0026#34;当前状态: %s, 事件: %s, 后来状态: %s\\n\u0026#34;, s, event, s2) return } fmt.Println(\u0026#34;当前状态无法流转\u0026#34;) } type State uint8 const ( Default = iota MarkPick Mark InternalPick Internal CheckPick Check Finish ) var stateName = map[State]string{ Default: \u0026#34;默认\u0026#34;, MarkPick: \u0026#34;标注待领取\u0026#34;, Mark: \u0026#34;标注中\u0026#34;, InternalPick: \u0026#34;内检待领取\u0026#34;, Internal: \u0026#34;内检中\u0026#34;, CheckPick: \u0026#34;验收待领取\u0026#34;, Check: \u0026#34;验收中\u0026#34;, Finish: \u0026#34;已完成\u0026#34;, } type Event string const ( Receive = \u0026#34;Receive\u0026#34; Submit = \u0026#34;Submit\u0026#34; CallBack = \u0026#34;CallBack\u0026#34; ) var transitions = map[State]map[Event]State{ MarkPick: { Receive: Mark, }, Mark: { Submit: InternalPick, }, InternalPick: { Receive: Internal, }, Internal: { Submit: CheckPick, CallBack: MarkPick, }, CheckPick: { Receive: Check, }, Check: { CallBack: InternalPick, Submit: Finish, }, } 在这个示例中，我们定义了一个State类型和一个Event类型，分别表示状态和事件。然后，我们使用transitions来表示状态之间的转换关系，其中transitions是一个嵌套的映射表，它的键是起始状态，值是一个映射表，该映射表的键是事件，值是目标状态。\n我们还定义了一个Run函数，它接受当前状态和触发的事件作为参数。在Run函数中，我们首先检查是否存在从当前状态到目标状态的转换路径，如果存在，就执行相应的操作，并输出当前状态、触发的事件和目标状态。如果不存在转换路径，就输出\u0026quot;当前状态无法流转\u0026quot;。\n通过调用Run函数，我们可以模拟状态机的状态流转过程。在示例中的main函数中，我们执行了几个状态流转的例子，然后输出了相应的结果。\n这个示例只是一个简单的演示，实际项目中的状态流转可能会更加复杂。在实际应用中，你可以根据项目的需求和业务逻辑来定义和扩展状态机的状态、事件和转换规则。\n参考资料 有限状态机（维基百科） ","date":"Mar 25","permalink":"https://blog.kalifun.top/post/mathmodel/fsm_demo/","tags":null,"title":"自动化状态管理：优化项目开发中的状态流转"},{"categories":["golang","golang开源库"],"contents":" 编写高并发程序常常让人头疼:代码冗余、死锁风险、逻辑复杂等等。Go语言的标准库提供了sync.WaitGroup、channel等工具来实现并发控制,但使用起来还是有一些困难。conc项目就是为了解决这些痛点而生的。\n主要功能 1. WaitGroup 在编写并发demo时,我们经常需要用到sync.WaitGroup来等待所有goroutine执行完毕。每次都要添加Add(),在goroutine退出前调用Done(),最后Wait()等待,非常繁琐。\n标准库示例:\n1 2 3 4 5 6 7 8 9 10 11 12 func main() { var wg sync.WaitGroup for i := 0; i \u0026lt; 10; i++ { wg.Add(1) go func() { defer wg.Done() // 如果doSomething()panic,程序会崩溃 doSomething() }() } wg.Wait() } 使用conc后:\n1 2 3 4 5 6 7 func main() { var wg conc.WaitGroup for i := 0; i \u0026lt; 10; i++ { wg.Go(doSomething) } wg.Wait() } conc对WaitGroup进行了封装,自动执行Add和Done操作。更重要的是,如果任一goroutine发生panic,错误会被捕获,在Wait时安全重新panic,而不会直接导致程序崩溃。\n2. ForEach 在并发处理数据时,我们往往需要创建一个channel,启动多个goroutine从channel读取数据并处理。代码十分冗长:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 func process(values []int) { feeder := make(chan int, 8) var wg sync.WaitGroup for i := 0; i \u0026lt; 10; i++ { wg.Add(1) go func() { defer wg.Done() for elem := range feeder { handle(elem) } }() } for _, value := range values { feeder \u0026lt;- value } close(feeder) wg.Wait() } 使用conc的ForEach,实现变得十分精简:\n1 2 3 func process(values []int) { iter.ForEach(values, handle) } ForEach会自动启动足够数量的goroutine,并发读取slice中的数据,应用handle函数进行处理。\n3. Map 另一个常见场景是从外部接口获取数据,并并行处理这些数据生成新的结果。传统实现如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func concMap( input []int, f func(int) int, ) []int { res := make([]int, len(input)) var idx atomic.Int64 var wg sync.WaitGroup for i := 0; i \u0026lt; 10; i++ { wg.Add(1) go func() { defer wg.Done() for { i := int(idx.Add(1) - 1) if i \u0026gt;= len(input) { return } res[i] = f(input[i]) } }() } wg.Wait() return res } 使用conc的Map方法就简洁多了:\n1 2 3 4 5 6 func concMap( input []int, f func(*int) int, ) []int { return iter.Map(input, f) } Map会自动创建一组goroutine,并发地对slice中每个元素应用f函数,最终返回结果slice。\n代码分析 conc项目的核心是错误捕获和并发控制,下面分析其实现原理。\n1. Catcher Catcher用于捕获并保存panic产生的错误信息。它的核心是CompareAndSwap原子操作,确保多个goroutine同时捕获panic时也能保证数据安全。\n1 2 3 4 5 6 7 8 9 type Catcher struct { recovered atomic.Pointer[Recovered] } type Recovered struct { Value any Callers []uintptr Stack []byte } Catcher的Try方法用于执行传入的函数,在panic时通过recover捕获错误:\n1 2 3 4 5 6 7 8 9 10 11 func (p *Catcher) Try(f func()) { defer p.tryRecover() f() } func (p *Catcher) tryRecover() { if val := recover(); val != nil { rp := NewRecovered(1, val) p.recovered.CompareAndSwap(nil, \u0026amp;rp) } } Repanic则检查之前是否捕获了panic,如果有就重新panic,确保主goroutine能获取完整的错误堆栈信息。\n2. WaitGroup WaitGroup通过组合Catcher和sync.WaitGroup,实现自动错误捕获:\n1 2 3 4 5 6 7 8 9 10 11 12 type WaitGroup struct { wg sync.WaitGroup pc panics.Catcher } func (h *WaitGroup) Go(f func()) { h.wg.Add(1) go func() { defer h.wg.Done() h.pc.Try(f) }() } Go方法启动新的goroutine执行f,受Try保护,发生panic时被捕获到Catcher中。Wait则首先等待所有goroutine退出,之后检查Catcher中是否存在被捕获的panic,如果有就重新panic。\n3. ForEach和Map ForEach和Map的实现核心其实就是对slice的并发遍历,应用指定的处理函数。通过原子操作cnt确保索引唯一,goroutine安全地读取不同的slice元素。这里就不再赘述了。\n总的来说,conc项目通过对WaitGroup、channel等并发原语的封装,简化了并发程序的编写。同时其错误捕获机制能最大程度地避免由panic导致的程序崩溃,极大提高了程序的健壮性。这些设计思路和技术细节,无疑能给Go并发编程带来极大的启发。\n","date":"Mar 10","permalink":"https://blog.kalifun.top/post/golang/conc/","tags":null,"title":"解锁Go并发编程的新姿势 -- conc项目解析"},{"categories":["archlinux"],"contents":"I recently installed Arch. but my network card is not working.\nI was surprised, i still had to install the driver myself?\nThe Arch documentation is so rich.\nYou can visit this link.\nLook for problems 1 lspic -vnn -d 14e4: The NIC is already recognized by the system.\ndisplay message Check whether the system starts abnormally.\n1 dmesg I thought it was a driver error and I tried uninstalling the installation. does not solve the problem.\nhwinfo 1 hwinfo --netcard --bluetooth | grep -Ei \u0026#34;(speed|hotplug|model|status|cmd|file|detected|driver:)\u0026#34; | grep -v \u0026#34;Config S\u0026#34; To find the problem, the driver needs to execute the following command:\n1 modprobe wl But to restart, you still need to execute the command again.\nIt\u0026rsquo;s awful, I need to really fix it. Maybe execute a script at startup?\n","date":"Mar 06","permalink":"https://blog.kalifun.top/post/arch/broadcom_wireless_arch/","tags":null,"title":"Broadcom Wrieless Archlinux"},{"categories":null,"contents":"I left nothing behind\nIntroduction hi, I\u0026rsquo;am kalifun.\nI majored in information security in college and taught myself back-end development as a rookie.\nContact Me Github: kalifun\nEmail: a2FsaWZ1bkBvdXRsb29rLmNvbQ==\n","date":"Jan 19","permalink":"https://blog.kalifun.top/me/about/","tags":null,"title":"About Me"},{"categories":null,"contents":"","date":"Jan 01","permalink":"https://blog.kalifun.top/articles/","tags":null,"title":"Articles"}]